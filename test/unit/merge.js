/* eslint-env mocha */

const _ = require('lodash')
const { clone, pick } = _
const path = require('path')
const sinon = require('sinon')
const should = require('should')

const Merge = require('../../core/merge')
const metadata = require('../../core/metadata')

const configHelpers = require('../support/helpers/config')
const {
  onPlatform,
  onPlatforms
} = require('../support/helpers/platform')
const pouchHelpers = require('../support/helpers/pouch')
const dbBuilders = require('../support/builders/db')
const Builders = require('../support/builders')

/** Resolves with an object describing the side-effects of a Merge call.
 *
 * The returned object has the following properties:
 *
 * - `savedDocs`: Which docs were changed in `Pouch`
 * - `resolvedConflicts`: Which conflits were resolved on which side
 */
async function mergeSideEffects ({merge, pouch} /*: * */, mergeCall /*: (): Promise<*> */) {
  const { last_seq: lastSeq } = await pouch.db.changes({since: 'now'})

  sinon.spy(merge, 'resolveConflictAsync')

  await mergeCall()

  const opts = {since: lastSeq, include_docs: true}
  const { results } = await pouch.db.changes(opts)
  const savedDocs = results.map(({doc}) => {
    // Don't include _rev in assertions: they are randomly generated by Pouch,
    // which makes them hard to compare.
    delete doc._rev

    // Pouch serializes dates as strings, but input docs generally have Date
    // objects. Casting makes assertions easier in most cases.
    doc.updated_at = new Date(doc.updated_at)

    return doc
  })

  return {
    savedDocs,
    resolvedConflicts: merge.resolveConflictAsync.args.map(([side, doc, existing]) =>
      [
        side,
        // Include only properties that are relevant in conflict resolution:
        _.pick(doc, [
          // The path is necessary to:
          // - generate the new file/dir name including the conflict suffix.
          // - rename the conflicting file/dir on the local side.
          'path',
          // The remote._id is necessary to rename the conflicting file/dir on
          // the remote side. Actually the remote._rev is not used although
          // we're currently including it in the test-asserted data as part of
          // the remote property.
          'remote'
        ])
        // Don't include the existing version: it is only useful for
        // logging / debugging and has no impact on conflict resolution.
      ]
    )
  }
}

describe('Merge', function () {
  let builders

  before('instanciate config', configHelpers.createConfig)
  beforeEach('instanciate pouch', pouchHelpers.createDatabase)
  beforeEach('instanciate merge', function () {
    this.side = 'local'
    this.merge = new Merge(this.pouch)
    this.merge.local = {renameConflictingDocAsync: sinon.stub().resolves()}
    this.merge.remote = {renameConflictingDocAsync: sinon.stub().resolves()}
    builders = new Builders({pouch: this.pouch})
  })
  afterEach('clean pouch', pouchHelpers.cleanDatabase)
  after('clean config directory', configHelpers.cleanConfig)

  describe('addFile', function () {
    it('saves the new file', async function () {
      let doc = {
        _id: metadata.id('foo/new-file'),
        path: 'foo/new-file',
        md5sum: 'adc83b19e793491b1c6ea0fd8b46cd9f32e592fc',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      await this.merge.addFileAsync(this.side, doc)
      const res = await this.pouch.db.get(doc._id)
      doc.updated_at = doc.updated_at.toISOString()
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
    })

    describe('when a file with the same path exists', function () {
      beforeEach('create a file', async function () {
        this.file = {
          _id: 'BUZZ.JPG',
          path: 'BUZZ.JPG',
          docType: 'file',
          md5sum: '1111111111111111111111111111111111111111',
          updated_at: new Date(),
          tags: ['foo'],
          size: 12345,
          class: 'image',
          mime: 'image/jpeg',
          ino: 123
        }
        await this.pouch.db.put(this.file)
      })

      it('can update the metadata', async function () {
        let was = clone(this.file)
        this.file.tags = ['bar', 'baz']
        this.file.updated_at = new Date()
        let doc = clone(this.file)
        delete doc.size
        delete doc.class
        delete doc.mime
        delete doc.ino
        this.file.updated_at = doc.updated_at.toISOString()
        await this.merge.addFileAsync(this.side, doc)
        const res = await this.pouch.db.get(doc._id)
        res.should.have.properties(this.file)
        res.size.should.equal(was.size)
        res.class.should.equal(was.class)
        res.mime.should.equal(was.mime)
        res.sides.local.should.equal(2)
        res.ino.should.equal(was.ino)
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function () {
        await builders.metafile().path('bar').create()
        const doc = builders.metafile().path('BAR').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, doc)
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, _.pick(doc, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function () {
        await builders.metafile().path('bar').create()
        const doc = builders.metafile().path('BAR').build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, doc)
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults({
              updated_at: new Date(doc.updated_at) // FIXME: Stop mixing dates & strings
            }, doc)
          ],
          resolvedConflicts: []
        })
      })
    })

    it('resolves a conflict with an existing dir', async function () {
      const existingLocalDir = await builders.metadir().sides({local: 1}).create()
      const newRemoteFile = builders.metafile().path(existingLocalDir.path).unmerged('remote').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing for an already merged file (aka idempotence)', async function () {
      const mergedFile = await builders.metafile().sides({remote: 1}).create()
      const sameFile = builders.metafile(mergedFile).unmerged('remote').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict on remote file addition with unsynced local file addition', async function () {
      const unsyncedLocalFile = await builders.metafile().sides({local: 1}).noRemote().data('local content').create()
      const newRemoteFile = builders.metafile().path(unsyncedLocalFile.path).unmerged('remote').data('remote content').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('overrides an unsynced local addition with a local update detected by initial scan', async function () {
      const initialFile = await builders.metafile().sides({local: 1}).ino(123).noRemote().data('initial content').create()
      const offUpdate = await builders.metafile(initialFile).unmerged('local').data('off update').newerThan(initialFile).build()

      const sideEffects = await mergeSideEffects(this, () =>
      this.merge.addFileAsync('local', _.cloneDeep(offUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [{
          _id: initialFile._id,
          docType: 'file',
          ino: initialFile.ino,
          md5sum: offUpdate.md5sum,
          path: initialFile.path,
          sides: {local: 2},
          size: offUpdate.size,
          tags: initialFile.tags, // tags can't be updated on the local side
          updated_at: offUpdate.updated_at
        }],
        resolvedConflicts: []
      })
    })

    it('overrides an unsynced local update with a new one detected by local initial scan', async function () {
      const initial = await builders.metafile().path('yafile').sides({local: 1}).ino(37).data('initial content').create()
      const synced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      const firstUpdate = await builders.metafile(synced).sides({local: 3, remote: 2}).data('first update').create()
      const secondUpdate = builders.metafile(firstUpdate).unmerged('local').data('second update').newerThan(firstUpdate).build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(secondUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          {
            _id: initial._id,
            docType: initial.docType,
            ino: initial.ino,
            md5sum: secondUpdate.md5sum,
            path: initial.path,
            remote: synced.remote,
            sides: {local: 4, remote: 2},
            size: secondUpdate.size,
            tags: initial.tags, // can't have been updated on the local side
            updated_at: secondUpdate.updated_at
          }
        ],
        resolvedConflicts: []
      })
    })

    it('does not override unsynced remote update with local initial scan of previous file content', async function () {
      const initial = await builders.metafile().sides({local: 1}).data('previous content').create()
      const synced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      await builders.metafile(synced).sides({local: 2, remote: 3}).data('remote update').create()
      const sameAsSynced = builders.metafile(synced).unmerged('local').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(sameAsSynced))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict between a local update detected on initial scan & an already merged remote update', async function () {
      const initial = await builders.metafile().sides({local: 1}).data('initial content').create()
      const synced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      const remoteUpdate = await builders.metafile(synced).sides({local: 2, remote: 3}).data('remote update').create()
      const localUpdate = builders.metafile(synced).unmerged('local').data('local update').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', localUpdate)
      )

      should(sideEffects).deepEqual({
        // FIXME: Local update won't be merged until next change/restart?
        // FIXME: Is remote version properly dissociated from local one?
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(remoteUpdate, ['path', 'remote'])]
        ]
      })
    })
  })

  describe('updateFile', () => {
    beforeEach('simulate local merge', async function () {
      this.file = {
        _id: 'FIZZBUZZ.JPG',
        path: 'FIZZBUZZ.JPG',
        docType: 'file',
        md5sum: '1111111111111111111111111111111111111111',
        updated_at: new Date(),
        tags: ['foo'],
        size: 12345,
        class: 'image',
        mime: 'image/jpeg',
        ino: 3456
      }
      metadata.markSide('local', this.file)
      const { rev } = await this.pouch.db.put(this.file)
      this.file._rev = rev
    })
    beforeEach('simulate remote sync', async function () {
      this.file.remote = {
        _id: dbBuilders.id(),
        _rev: dbBuilders.rev(1)
      }
      metadata.markAsUpToDate(this.file)
      const { rev } = await this.pouch.db.put(this.file)
      this.file._rev = rev
    })

    it('creates the file if it does not exist', async function () {
      let doc = {
        _id: 'FOOBAR/NEW-FILE',
        path: 'FOOBAR/NEW-FILE',
        md5sum: 'adc83b19e793491b1c6ea0fd8b46cd9f32e592fc',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      await this.merge.updateFileAsync(this.side, doc)
      const res = await this.pouch.db.get(doc._id)
      doc.updated_at = doc.updated_at.toISOString()
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
    })

    it('updates the metadata when content is the same', async function () {
      let was = clone(this.file)
      this.file.tags = ['bar', 'baz']
      this.file.updated_at = new Date()
      let doc = clone(this.file)
      delete doc.size
      delete doc.class
      delete doc.mime
      delete doc.ino
      this.file.updated_at = doc.updated_at.toISOString()
      await this.merge.updateFileAsync(this.side, doc)
      const res = await this.pouch.db.get(doc._id)
      res.should.have.properties(_.omit(this.file, ['_rev']))
      res.size.should.equal(was.size)
      res.class.should.equal(was.class)
      res.mime.should.equal(was.mime)
      res.ino.should.equal(was.ino)
      res.sides.local.should.equal(3)
    })

    it('overwrite the content when it was changed', async function () {
      let doc = {
        _id: 'FIZZBUZZ.JPG',
        path: 'FIZZBUZZ.JPG',
        docType: 'file',
        md5sum: '3333333333333333333333333333333333333333',
        tags: ['qux', 'quux']
      }
      await this.merge.updateFileAsync(this.side, clone(doc))
      const res = await this.pouch.db.get(this.file._id)
      res.should.have.properties(doc)
      should.not.exist(res.size)
      should.not.exist(res.class)
      should.not.exist(res.mime)
      res.sides.local.should.equal(3)
    })

    it('resolves a conflict with an existing directory', async function () {
      const existingLocalDir = await builders.metadir().sides({local: 1}).create()
      const newRemoteFile = builders.metafile().path(existingLocalDir.path).unmerged('remote').build()

      await should(
        this.merge.updateFileAsync('local', newRemoteFile)
      ).be.rejectedWith(/conflict/)
      // FIXME: Why don't we resolve the conflict like everywhere else?
    })

    it('resolves a conflict between a new remote update and a previous local version', async function () {
      const initial = await builders.metafile().sides({local: 1}).ino(456).data('initial content').create()
      const synced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      const mergedLocalUpdate = await builders.metafile(synced).sides({local: 3, remote: 2}).data('local update').create()
      const newRemoteUpdate = builders.metafile(synced).unmerged('remote').data('remote update').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', newRemoteUpdate)
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          {
            _id: initial._id,
            docType: initial.docType,
            ino: initial.ino,
            md5sum: mergedLocalUpdate.md5sum,
            path: initial.path,
            sides: {local: 3},
            size: mergedLocalUpdate.size,
            // no remote since file was dissociated
            tags: initial.tags, // could only have been updated from a remote update
            updated_at: new Date(mergedLocalUpdate.updated_at) // FIXME: Stop mixing dates & strings
          }
        ],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('resolves a conflict between a new local update and a previous remote one', async function () {
      const initial = await builders.metafile().sides({local: 1}).data('initial content').create()
      const synced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      await builders.metafile(synced).sides({local: 2, remote: 3}).data('remote update').create()
      const newLocalUpdate = builders.metafile(synced).unmerged('local').data('local update').build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', newLocalUpdate)
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['local', _.pick(newLocalUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing when existing file is up to date', async function () {
      const initial = await builders.metafile().sides({local: 1}).data('initial content').create()
      const initialSynced = await builders.metafile(initial).sides({local: 2, remote: 2}).create()
      const update = await builders.metafile(initialSynced).sides({local: 3, remote: 2}).data('updated content').create()
      const updateSynced = await builders.metafile(update).sides({local: 4, remote: 4}).create()
      const sameUpdate = builders.metafile(updateSynced).sides(update.sides).build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', sameUpdate)
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })
  })

  describe('putFolder', () => {
    it('saves the new folder', async function () {
      let doc = {
        _id: 'FOO/NEW-FOLDER',
        path: 'FOO/NEW-FOLDER',
        docType: 'folder',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      await this.merge.putFolderAsync(this.side, doc)
      doc.updated_at = doc.updated_at.toISOString()
      const res = await this.pouch.db.get(doc._id)
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
    })

    it('saves a new version of an existing folder', async function () {
      const old = await builders.metadir().path('existing-folder').create()
      const doc = builders.metadir(old).whateverChange().changedSide(this.side).build()

      await this.merge.putFolderAsync(this.side, doc)

      const result = await this.pouch.db.get(doc._id)
      should(result._rev).not.equal(old._rev)
      should(result).have.properties(_.omit(doc, '_rev'))
    })

    it('does nothing when existing folder is up to date', async function () {
      const old = await builders.metadir().path('up-to-date-folder').create()
      const doc = _.cloneDeep(old)

      await this.merge.putFolderAsync(this.side, doc)

      const result = await this.pouch.db.get(doc._id)
      should(result).deepEqual(old)
    })

    it('resolves a conflict with an existing file', async function () {
      const existingLocalFile = await builders.metafile().sides({local: 1}).create()
      const newRemoteDir = builders.metadir().path(existingLocalFile.path).sides({remote: 1}).build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', newRemoteDir)
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteDir, ['path', 'remote'])]
        ]
      })
    })

    describe('identity conflict with an existing dir', () => {
      let alfred, Alfred

      beforeEach(async () => {
        alfred = await builders.metadir().path('alfred').create()
        Alfred = await builders.metadir().path('Alfred').build()
      })

      onPlatforms(['win32', 'darwin'], () => {
        it('is resolved', async function () {
          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.putFolderAsync(this.side, Alfred)
          )

          should(sideEffects).deepEqual({
            savedDocs: [],
            resolvedConflicts: [
              [this.side, _.pick(Alfred, ['path', 'remote'])]
            ]
          })
        })
      })

      onPlatform('linux', () => {
        it('does not happen', async function () {
          await this.merge.putFolderAsync(this.side, Alfred)

          should(this.merge.resolveConflictAsync).not.have.been.called()
          // Same as Alfred except _rev was added
          should(await this.pouch.db.get(Alfred._id)).have.properties(Alfred)
          should(await this.pouch.db.get(alfred._id)).deepEqual(alfred)
        })
      })
    })
  })

  describe('moveFile', function () {
    it('saves the new file and deletes the old one', async function () {
      let was = {
        _id: 'FOO/OLD',
        path: 'FOO/OLD',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux'],
        sides: {
          local: 1,
          remote: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'},
        trashed: true
      }
      let doc = {
        _id: 'FOO/NEW',
        path: 'FOO/NEW',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      await this.merge.moveFileAsync(this.side, clone(doc), clone(was))
      const res = await this.pouch.db.get(doc._id)
      doc.updated_at = doc.updated_at.toISOString()
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
      should.not.exist(res.trashed)
      await should(this.pouch.db.get(was._id)).be.rejectedWith({status: 404})
    })

    it('adds missing fields', async function () {
      let doc = {
        _id: 'FOO/NEW-MISSING-FIELDS.JPG',
        path: 'FOO/NEW-MISSING-FIELDS.JPG',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517'
      }
      let was = {
        _id: 'FOO/OLD-MISSING-FIELDS.JPG',
        path: 'FOO/OLD-MISSING-FIELDS.JPG',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux'],
        size: 5426,
        class: 'image',
        mime: 'image/jpeg',
        ino: 3854,
        sides: {
          local: 1,
          remote: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'}
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      await this.merge.moveFileAsync(this.side, clone(doc), clone(was))
      const res = await this.pouch.db.get(doc._id)
      res.should.have.properties(doc)
      should.exist(res.size)
      should.exist(res.class)
      should.exist(res.mime)
      should.exist(res.ino)
    })

    it('adds a hint for writers to know that it is a move', async function () {
      await builders.metadir().path('FOO').create()
      let doc = {
        _id: 'FOO/NEW-HINT',
        path: 'FOO/NEW-HINT',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      let was = {
        _id: 'FOO/OLD-HINT',
        path: 'FOO/OLD-HINT',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux'],
        sides: {
          local: 1,
          remote: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'}
      }
      let opts = {
        include_docs: true,
        live: true,
        since: 'now'
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      const infoPromise = new Promise((resolve, reject) => {
        this.pouch.db.changes(opts).on('change', function (info) {
          this.cancel()
          resolve(info)
        })
      })
      await this.merge.moveFileAsync(this.side, clone(doc), clone(was))
      const info = await infoPromise
      should(info).have.property('id', was._id)
      should(info.doc).have.property('moveTo', doc._id)
    })

    it('resolves a conflict with an existing destination', async function () {
      const existing = await builders.metafile().path('DST_FILE').create()
      const was = await builders.metafile().path('SRC_FILE').upToDate().create()
      const doc = builders.metafile(was).path(existing.path).noRev().build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const {_id: dstId, path: dstPath} = _.find(
        sideEffects.savedDocs,
        ({path}) => path.match(/conflict/)
      )
      const src = {
        _deleted: true,
        _id: was._id,
        docType: was.docType,
        md5sum: was.md5sum,
        moveTo: dstId,
        path: was.path,
        remote: was.remote,
        sides: {local: 2, remote: 2},
        size: was.size,
        tags: was.tags,
        updated_at: new Date(was.updated_at) // FIXME: Stop mixing dates & strings
      }
      const dst = {
        _id: dstId,
        docType: doc.docType,
        md5sum: doc.md5sum,
        moveFrom: _.defaults({
          _rev: was._rev,
          moveTo: doc._id, // FIXME: Should be doc._id?
          updated_at: was.updated_at // FIXME: Stop mixing dates & strings
        }, src),
        path: dstPath,
        remote: doc.remote,
        sides: {local: 1},
        size: doc.size,
        tags: doc.tags,
        updated_at: new Date(doc.updated_at) // FIXME: Stop mixing dates & strings
      }
      should(sideEffects).deepEqual({
        savedDocs: [src, dst],
        resolvedConflicts: [
          ['local', {path: doc.path, remote: doc.remote}]
        ]
      })
    })

    it('does not identify an identical renaming as a conflict', async function () {
      const banana = await builders.metafile().path('banana').upToDate().create()
      const BANANA = _({_id: metadata.id('BANANA'), path: 'BANANA'})
        .defaults(banana)
        .omit(['_rev'])
        .value()

      sinon.spy(this.merge, 'resolveConflictAsync')
      await this.merge.moveFileAsync(this.side, BANANA, banana)

      should(this.merge.resolveConflictAsync.args).not.have.been.called()
      should(await this.pouch.db.get(BANANA._id)).have.properties(
        _.omit(
          BANANA,
          ['class', 'mime', 'ino']
        )
      )
      if (banana._id !== BANANA._id) {
        await should(this.pouch.db.get(banana._id)).be.rejectedWith({status: 404})
      }
    })

    it('identifies a local move without existing remote side as an addition', async function () {
      let doc = {
        _id: 'FOO/NEW',
        path: 'FOO/NEW',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      let was = {
        _id: 'FOO/OLD',
        path: 'FOO/OLD',
        md5sum: 'ba1368789cce95b574dec70dfd476e61cbf00517',
        docType: 'file',
        updated_at: new Date(),
        tags: ['courge', 'quux'],
        sides: {
          local: 1
        }
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      await this.merge.moveFileAsync('local', clone(doc), clone(was))
      const res = await this.pouch.db.get(doc._id)
      doc.updated_at = doc.updated_at.toISOString()
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
      should(res.moveFrom).be.undefined()
      should(res.moveTo).be.undefined()
      await should(this.pouch.db.get(was._id)).be.rejectedWith({status: 404})
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function () {
        const identical = await builders.metafile().path('QUX').create()
        const was = builders.metafile().path('baz').upToDate().build()
        const doc = _.defaults({_id: identical._id, path: 'qux'}, was)

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, doc, was)
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, _.pick(doc, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function () {
        await builders.metafile().path('QUX').create()
        const baz = builders.metafile().path('baz').upToDate().build()
        const qux = _.defaults({_id: 'qux', path: 'qux'}, baz)

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(this.side, _.cloneDeep(qux), _.cloneDeep(baz))
        )

        const src = {
          _deleted: true,
          _id: baz._id,
          docType: baz.docType,
          md5sum: baz.md5sum,
          moveTo: qux._id,
          path: baz.path,
          remote: baz.remote,
          sides: {local: 1, remote: 2},
          size: baz.size,
          tags: baz.tags,
          updated_at: new Date(baz.updated_at) // FIXME: Stop mixing dates & strings
        }
        const dst = {
          _id: qux._id,
          docType: qux.docType,
          md5sum: baz.md5sum,
          moveFrom: _.defaults({
            updated_at: baz.updated_at // FIXME: Stop mixing dates & strings
          }, src),
          path: qux.path,
          remote: qux.remote,
          sides: {local: 1, remote: 2},
          size: qux.size,
          tags: [],
          updated_at: new Date(qux.updated_at) // FIXME: Stop mixing dates & strings
        }
        should(sideEffects).deepEqual({
          savedDocs: [src, dst],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('moveFolder', function () {
    // @TODO fixme intermittent failure
    // `Error in .on("change", function): {
    // AssertionError: expected 'FOOBAR/OLD' to be 'FOOBAR/OLD-HINT'`
    // → https://travis-ci.org/cozy-labs/cozy-desktop/jobs/269106208#L2224
    it('saves the new folder and deletes the old one', async function () {
      let doc = {
        _id: 'FOOBAR/NEW',
        path: 'FOOBAR/NEW',
        docType: 'folder',
        updated_at: new Date('2018-09-02T00:00:00.000Z'),
        tags: ['courge', 'quux']
      }
      let was = {
        _id: 'FOOBAR/OLD',
        path: 'FOOBAR/OLD',
        docType: 'folder',
        updated_at: new Date('2018-09-01T00:00:00.000Z'),
        tags: ['courge', 'quux'],
        sides: {
          local: 1,
          remote: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'},
        ino: 666,
        trashed: true
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      await this.merge.moveFolderAsync(this.side, clone(doc), clone(was))
      const res = await this.pouch.db.get(doc._id)
      doc.updated_at = doc.updated_at.toISOString()
      res.should.have.properties(doc)
      res.sides.local.should.equal(1)
      res.should.have.property('ino', was.ino)
      should.not.exist(res.trashed)
      await should(this.pouch.db.get(was._id)).be.rejectedWith({status: 404})
    })

    it('adds a hint for writers to know that it is a move', async function () {
      await builders.metadir().path('FOOBAR').create()
      let doc = {
        _id: 'FOOBAR/NEW-HINT',
        path: 'FOOBAR/NEW-HINT',
        docType: 'folder',
        updated_at: new Date(),
        tags: ['courge', 'quux']
      }
      let was = {
        _id: 'FOOBAR/OLD-HINT',
        path: 'FOOBAR/OLD-HINT',
        docType: 'folder',
        updated_at: new Date(),
        tags: ['courge', 'quux'],
        sides: {
          local: 1,
          remote: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'}
      }
      let opts = {
        include_docs: true,
        live: true,
        since: 'now'
      }
      const inserted = await this.pouch.db.put(clone(was))
      was._rev = inserted.rev
      const infoPromise = new Promise((resolve, reject) => {
        this.pouch.db.changes(opts).on('change', function (info) {
          this.cancel()
          resolve(info)
        })
      })
      await this.merge.moveFolderAsync(this.side, clone(doc), clone(was))
      const info = await infoPromise
      should(info).have.property('id', was._id)
      should(info.doc).have.property('moveTo', doc._id)
    })

    it('resolves a conflict with an existing destination', async function () {
      const existing = await builders.metadir().path('DST_DIR').upToDate().create()
      const was = await builders.metadir().path('SRC_DIR').upToDate().create()
      const doc = builders.metadir(was).path(existing.path).noRev().build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const {_id: dstId, path: dstPath} = _.find(
        sideEffects.savedDocs,
        ({path}) => path.match(/conflict/)
      )
      const src = {
        _deleted: true,
        _id: was._id,
        docType: was.docType,
        moveTo: dstId,
        path: was.path,
        remote: was.remote,
        sides: {local: 2, remote: 2},
        tags: was.tags,
        updated_at: new Date(was.updated_at) // FIXME: Stop mixing dates & strings
      }
      const dst = {
        _id: dstId,
        docType: doc.docType,
        moveFrom: _.defaults({
          _rev: was._rev,
          updated_at: was.updated_at
        }, src),
        path: dstPath,
        remote: doc.remote,
        sides: {local: 1},
        tags: doc.tags,
        updated_at: new Date(doc.updated_at) // FIXME: Stop mixing dates & strings
      }

      should(sideEffects).deepEqual({
        savedDocs: [src, dst],
        resolvedConflicts: [
          [this.side, _.pick(doc, ['path', 'remote'])]
        ]
      })
    })

    it('does not create conflict for local-only existing folder.', async function () {
      const existing = await builders.metadir().sides({local: 1}).unmerged('local').path('DST_DIR2').create()
      const was = await builders.metadir().path('SRC_DIR2').upToDate().create()
      const doc = builders.metadir(was).path(existing.path).noRev().build()

      await this.merge.moveFolderAsync(this.side, doc, was)

      should(this.merge.resolveConflictAsync).not.have.been.called()
      const newMetadata = await this.pouch.db.get(existing._id)
      newMetadata.should.have.property('remote')
      newMetadata.remote.should.have.property('_id', was.remote._id)
    })

    it('does not identify an identical renaming as a conflict', async function () {
      const apple = await builders.metadir().path('apple').upToDate().create()
      const APPLE = _({_id: metadata.id('APPLE'), path: 'APPLE'})
        .defaults(apple)
        .omit(['_rev'])
        .value()

      sinon.spy(this.merge, 'resolveConflictAsync')
      await this.merge.moveFolderAsync(this.side, APPLE, apple)

      should(this.merge.resolveConflictAsync.args).not.have.been.called()
      should(await this.pouch.db.get(APPLE._id)).have.properties(
        _.omit(
          APPLE,
          ['ino']
        )
      )
      if (apple._id !== APPLE._id) {
        await should(this.pouch.db.get(apple._id)).be.rejectedWith({status: 404})
      }
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function () {
        const LINUX = await builders.metadir().path('LINUX').create()
        const torvalds = builders.metadir().path('torvalds').upToDate().build()
        const linux = _.defaults({_id: LINUX._id, path: 'linux'}, torvalds)

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, linux, torvalds)
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, _.pick(linux, ['path', 'remote'])]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function () {
        await builders.metadir().path('NUKEM').create()
        const duke = builders.metadir().path('duke').upToDate().build()
        const nukem = _.defaults({_id: 'nukem', path: 'nukem'}, duke)

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(this.side, nukem, duke)
        )

        const src = {
          _deleted: true,
          _id: duke._id,
          docType: duke.docType,
          moveTo: nukem._id,
          path: duke.path,
          remote: duke.remote,
          sides: {local: 1, remote: 2},
          tags: duke.tags,
          updated_at: new Date(duke.updated_at) // FIXME: Stop mixing dates & strings
        }
        const dst = {
          _id: nukem._id,
          docType: nukem.docType,
          moveFrom: _.defaults({
            updated_at: duke.updated_at // FIXME: Stop mixing dates & strings
          }, src),
          path: nukem.path,
          remote: nukem.remote,
          sides: {local: 1, remote: 2},
          tags: nukem.tags,
          updated_at: new Date(nukem.updated_at) // FIXME: Stop mixing dates & strings
        }
        should(sideEffects).deepEqual({
          savedDocs: [src, dst],
          resolvedConflicts: []
        })
      })
    })

    it('handles overwritten descendants', async function () {
      await builders.metafile().path('src/file').upToDate().create()
      await builders.metafile().path('dst/file').upToDate().create()
      const oldDst = builders.metadir().path('dst').build()
      const src = await builders.metadir().path('src').upToDate().create()
      const dst = builders.metadir().path('dst').overwrite(oldDst).build()

      await this.merge.moveFolderAsync(this.side, dst, src)
    })
  })

  describe('moveFolderRecursively', function () {
    beforeEach(async function () {
      await pouchHelpers.createParentFolder(this.pouch)
      await pouchHelpers.createFolder(this.pouch, 9)
      await pouchHelpers.createFile(this.pouch, 9)
      // FIXME: Test doesn't fail without those two lines
      const file = await this.pouch.db.get(metadata.id(path.normalize('my-folder/file-9')))
      await this.pouch.db.put(_.defaults({trashed: true}, file))
    })

    it('move the folder and files/folders inside it', async function () {
      let doc = {
        _id: 'DESTINATION',
        path: 'DESTINATION',
        docType: 'folder',
        updated_at: new Date(),
        tags: [],
        sides: {
          remote: 1,
          local: 1
        },
        remote: {_id: 'XXX', _rev: '1-abc'}
      }
      const was = await this.pouch.db.get(metadata.id('my-folder'))
      await this.merge.moveFolderRecursivelyAsync('local', doc, was)
      let ids = ['', path.normalize('/folder-9'), path.normalize('/file-9')]
      for (let id of ids) {
        const res = await this.pouch.db.get(metadata.id(`DESTINATION${id}`))
        should.exist(res)
        should(res.path).eql(`DESTINATION${id}`)
        should.not.exist(res.trashed)
        if (id !== '') { // parent sides are updated in moveFolderAsync()
          should(res.sides.local).not.eql(1)
        }
        await should(this.pouch.db.get(metadata.id(`my-folder${id}`)))
          .be.rejectedWith({status: 404})
      }
    })

    it('adds an unsynced file to the destination folder', async function () {
      const fileName = 'unsynced-file'
      const srcFolder = await builders.metadir().path('ADDED_DIR').upToDate().create()
      await builders.metafile().path(path.normalize(`${srcFolder.path}/${fileName}`)).sides({ local: 1 }).create()

      const dstFolder = builders.metadir(srcFolder).path('MOVED_DIR').sides({}).noRev().build()
      await this.merge.moveFolderRecursivelyAsync('local', dstFolder, srcFolder)

      const movedFile = await this.pouch.db.get(metadata.id(path.normalize(`${dstFolder.path}/${fileName}`)))
      should(movedFile).have.property('path', path.normalize(`${dstFolder.path}/${fileName}`))
      await should(
        this.pouch.db.get(metadata.id(`${srcFolder.path}/{fileName}`))
      ).be.rejectedWith({status: 404})
    })
  })

  describe('trashFolderAsync', () => {
    it('does not trash a folder if the other side has added a new file in it', async function () {
      const dir = await builders.metadir().path('trashed-folder').trashed().create()
      await builders.metafile().path(path.normalize('trashed-folder/file')).notUpToDate().create()
      const was = pick(dir, ['_id', 'path', 'docType', 'trashed'])
      const doc = _.defaults({
        path: `.cozy_trash/${was.path}`
      }, was)

      await this.merge.trashFolderAsync(this.side, was, doc)

      const saved = await this.pouch.db.get(was._id)
      should(saved).not.have.property('trashed')
      should(saved.sides).deepEqual({remote: 2})
    })
  })

  describe('deleteFile', () =>
    it('deletes a file', async function () {
      let doc = {
        _id: path.normalize('TO-DELETE/FILE'),
        path: path.normalize('TO-DELETE/FILE'),
        docType: 'file',
        md5sum: 'BADBEEF',
        sides: {
          local: 1
        }
      }
      await this.pouch.db.put(doc)
      await this.merge.deleteFileAsync(this.side, doc)
      await should(this.pouch.db.get(doc._id)).be.rejectedWith({status: 404})
    })
  )

  describe('deleteFolder', function () {
    it('deletes a folder', async function () {
      let doc = {
        _id: path.normalize('TO-DELETE/FOLDER'),
        path: path.normalize('TO-DELETE/FOLDER'),
        docType: 'folder',
        sides: {
          local: 1
        }
      }
      await this.pouch.db.put(doc)
      await this.merge.deleteFolderAsync(this.side, doc)
      await should(this.pouch.db.get(doc._id)).be.rejectedWith({status: 404})
    })

    it('remove files in the folder', async function () {
      let doc = {
        _id: path.normalize('FOO/TO-REMOVE'),
        path: path.normalize('FOO/TO-REMOVE'),
        docType: 'folder',
        sides: {
          local: 1
        }
      }
      await this.pouch.db.put(doc)
      for (let name of ['baz', 'qux', 'quux']) {
        let file = {
          _id: path.normalize(`FOO/TO-REMOVE/${name}`),
          path: path.normalize(`FOO/TO-REMOVE/${name}`),
          docType: 'file',
          md5sum: 'BADBEEF'
        }
        await this.pouch.db.put(file)
      }
      await this.merge.deleteFolderAsync(this.side, doc)
      const docs = await this.pouch.byPathAsync(path.normalize('FOO/TO-REMOVE'))
      docs.length.should.be.equal(0)
    })

    it('remove nested folders', async function () {
      let base = path.normalize('NESTED/TO-DELETE')
      for (let name of ['', '/b', '/b/c', '/b/d']) {
        let doc = {
          _id: path.normalize(`${base}${name}`),
          path: path.normalize(`${base}${name}`),
          docType: 'folder',
          sides: {
            local: 1
          }
        }
        await this.pouch.db.put(doc)
      }
      await this.merge.deleteFolderAsync(this.side, {_id: base, path: base})
      const res = await this.pouch.db.allDocs()
      for (let row of Array.from(res.rows)) {
        row.id.should.not.match(/^NESTED/i)
      }
    })
  })

  xdescribe('trashAsync', () => {
    context('when metadata are found in Pouch', () => {
      it('updates it with trashed property and up-to-date sides info', async function () {
        const doc = {_id: 'existing-metadata'}
        await this.pouch.db.put(_.defaults({sides: {local: 1, remote: 1}}, doc))

        await this.merge.trashAsync(this.side, doc)

        const updated = await this.pouch.db.get(doc._id)
        should(updated).have.properties(_.defaults({
          trashed: true,
          sides: {
            local: 2,
            remote: 1
          }
        }, doc))
      })
    })

    context('when metadata are not found in Pouch', () => {
      it('does nothing', async function () {
        const doc = {_id: 'missing-metadata'}

        await this.merge.trashAsync(this.side, doc)

        await should(this.pouch.db.get(doc._id))
          .be.rejectedWith({status: 404})
      })
    })

    context('when docType does not match', () => {
      it('tries to resolve the conflict', async function () {
        const doc = {_id: 'conflicting-doctype', docType: 'folder', path: 'conflicting-doctype'}
        await this.pouch.db.put(_.defaults({docType: 'file'}, doc))

        await this.merge.trashAsync(this.side, doc)

        should(this.merge.resolveConflictAsync).have.been.calledWith(this.side, doc)
        should(this.pouch.put).not.have.been.called()
      })
    })
  })
})
